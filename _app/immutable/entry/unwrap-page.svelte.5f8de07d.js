import { S as SvelteComponentDev, i as init$1, s as safe_not_equal, d as dispatch_dev, G as validate_store, H as component_subscribe, v as validate_slots, N as createEventDispatcher, p as element, y as text, c as space, C as create_component, q as claim_element, r as children, z as claim_text, l as detach_dev, f as claim_space, D as claim_component, x as add_location, u as attr_dev, w as set_style, g as insert_hydration_dev, J as append_hydration_dev, W as set_input_value, E as mount_component, a6 as action_destroyer, L as listen_dev, A as set_data_dev, X as to_number, k as transition_in, h as transition_out, F as destroy_component, O as run_all, M as prevent_default, I as noop, o as onMount, e as empty, B as group_outros, j as check_outros } from '../chunks/index.7b7857c7.js';
import { s as sbtcConfig } from '../chunks/stores.f738a24a.js';
import { F as FeeDisplay, P as PegTransaction, a as assert$1, M as MAGIC_BYTES_TESTNET, b as MAGIC_BYTES_MAINNET, c as PEGOUT_OPCODE, d as Principal, U as UTXOSelection, S as SbtcWalletDisplay, e as SignTransaction, f as SignTransactionWeb } from '../chunks/SbtcWalletDisplay.55b88a5d.js';
import { T as TEST_NETWORK, N as NETWORK, h as hex, p as p2wpkh, b as Transaction, s as secp256k1, S as Script, O as OutScript, A as Address, R as RawTx, c as explorerAddressUrl } from '../chunks/utils.c9b3f15e.js';
import { f as utils, h as getPublicKey, j as schnorr, t as tupleCV, s as stringAsciiCV, u as uintCV, v as verifyMessageSignature, k as hashMessage, r as recoverPublicKey, m as bytesToHex$1, a as addresses, n as signMessage } from '../chunks/stacks_connect.579cfa64.js';
import { b as fetchUtxoSet, c as fetchCurrentFeeRates } from '../chunks/bridge_api.0c8320ca.js';
import { b as base } from '../chunks/paths.9c0123c2.js';

/* src/lib/components/unwrapper/PegOutAmount.svelte generated by Svelte v3.57.0 */
const file$2 = "src/lib/components/unwrapper/PegOutAmount.svelte";

// (47:8) {#if amtData.change > 0}
function create_if_block$2(ctx) {
	let span;
	let a;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			a = element("a");
			t = text("set max");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			a = claim_element(span_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, "set max");
			a_nodes.forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "/");
			attr_dev(a, "class", "");
			add_location(a, file$2, 46, 38, 2105);
			add_location(span, file$2, 46, 32, 2099);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, a);
			append_hydration_dev(a, t);

			if (!mounted) {
				dispose = listen_dev(a, "click", prevent_default(/*click_handler*/ ctx[6]), false, true, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(47:8) {#if amtData.change > 0}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div5;
	let div2;
	let label0;
	let span0;
	let t0_value = /*amtData*/ ctx[0].label + "";
	let t0;
	let t1;
	let span1;
	let t2;
	let input0;
	let t3;
	let div1;
	let div0;
	let t4_value = /*amtData*/ ctx[0].info + "";
	let t4;
	let t5;
	let t6;
	let div4;
	let label1;
	let span2;
	let t7;
	let t8;
	let span3;
	let t9;
	let input1;
	let t10;
	let div3;
	let t11;
	let t12;
	let feedisplay;
	let current;
	let mounted;
	let dispose;
	let if_block = /*amtData*/ ctx[0].change > 0 && create_if_block$2(ctx);

	feedisplay = new FeeDisplay({
			props: {
				amtData: /*amtData*/ ctx[0],
				currentPeg: /*pegAmount*/ ctx[1]
			},
			$$inline: true
		});

	feedisplay.$on("fee_rate_updated", /*changeRate*/ ctx[3]);

	const block = {
		c: function create() {
			div5 = element("div");
			div2 = element("div");
			label0 = element("label");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = space();
			span1 = element("span");
			t2 = space();
			input0 = element("input");
			t3 = space();
			div1 = element("div");
			div0 = element("div");
			t4 = text(t4_value);
			t5 = space();
			if (if_block) if_block.c();
			t6 = space();
			div4 = element("div");
			label1 = element("label");
			span2 = element("span");
			t7 = text("sBTC Dust Amount");
			t8 = space();
			span3 = element("span");
			t9 = space();
			input1 = element("input");
			t10 = space();
			div3 = element("div");
			t11 = text("Tiny amount of bitcoin is sent to the sBTC wallet for book keeping purposes");
			t12 = space();
			create_component(feedisplay.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div5 = claim_element(nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div2 = claim_element(div5_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			label0 = claim_element(div2_nodes, "LABEL", { for: true, class: true });
			var label0_nodes = children(label0);
			span0 = claim_element(label0_nodes, "SPAN", {});
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, t0_value);
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(label0_nodes);

			span1 = claim_element(label0_nodes, "SPAN", {
				class: true,
				"data-bs-toggle": true,
				"data-bs-placement": true,
				"data-bs-custom-class": true,
				title: true
			});

			children(span1).forEach(detach_dev);
			label0_nodes.forEach(detach_dev);
			t2 = claim_space(div2_nodes);

			input0 = claim_element(div2_nodes, "INPUT", {
				type: true,
				id: true,
				class: true,
				autocomplete: true
			});

			t3 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t4 = claim_text(div0_nodes, t4_value);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t6 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			label1 = claim_element(div4_nodes, "LABEL", { for: true, class: true });
			var label1_nodes = children(label1);
			span2 = claim_element(label1_nodes, "SPAN", {});
			var span2_nodes = children(span2);
			t7 = claim_text(span2_nodes, "sBTC Dust Amount");
			span2_nodes.forEach(detach_dev);
			t8 = claim_space(label1_nodes);

			span3 = claim_element(label1_nodes, "SPAN", {
				class: true,
				"data-bs-toggle": true,
				"data-bs-placement": true,
				"data-bs-custom-class": true,
				title: true
			});

			children(span3).forEach(detach_dev);
			label1_nodes.forEach(detach_dev);
			t9 = claim_space(div4_nodes);

			input1 = claim_element(div4_nodes, "INPUT", {
				type: true,
				id: true,
				class: true,
				style: true
			});

			t10 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true, title: true });
			var div3_nodes = children(div3);
			t11 = claim_text(div3_nodes, "Tiny amount of bitcoin is sent to the sBTC wallet for book keeping purposes");
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t12 = claim_space(div5_nodes);
			claim_component(feedisplay.$$.fragment, div5_nodes);
			div5_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span0, file$2, 40, 8, 1457);
			attr_dev(span1, "class", "pointer text-info");
			attr_dev(span1, "data-bs-toggle", "tooltip-ftux");
			attr_dev(span1, "data-bs-placement", "top");
			attr_dev(span1, "data-bs-custom-class", "custom-tooltip");
			attr_dev(span1, "title", "The amount of Bitcoin you want to swap for sBTC. The bitcoin is locked in the protocol and you convert your sBTC back to Bitcoin when you peg out.");
			add_location(span1, file$2, 41, 8, 1494);
			attr_dev(label0, "for", "transact-path");
			attr_dev(label0, "class", "d-flex justify-content-between");
			add_location(label0, file$2, 39, 6, 1382);
			attr_dev(input0, "type", "number");
			attr_dev(input0, "id", "from-address");
			attr_dev(input0, "class", "form-control");
			attr_dev(input0, "autocomplete", "off");
			add_location(input0, file$2, 43, 6, 1802);
			attr_dev(div0, "class", "text-small");
			add_location(div0, file$2, 45, 8, 2022);
			attr_dev(div1, "class", "text-small d-flex justify-content-between");
			add_location(div1, file$2, 44, 6, 1958);
			attr_dev(div2, "class", "col-12");
			add_location(div2, file$2, 38, 4, 1355);
			add_location(span2, file$2, 52, 8, 2336);
			attr_dev(span3, "class", "pointer text-info");
			attr_dev(span3, "data-bs-toggle", "tooltip-ftux");
			attr_dev(span3, "data-bs-placement", "top");
			attr_dev(span3, "data-bs-custom-class", "custom-tooltip");
			attr_dev(span3, "title", "A tiny amount of bitoin is sent to the sBTC to keep track of sBTC transactions.");
			add_location(span3, file$2, 53, 8, 2374);
			attr_dev(label1, "for", "transact-path");
			attr_dev(label1, "class", "d-flex justify-content-between");
			add_location(label1, file$2, 51, 6, 2261);
			attr_dev(input1, "type", "number");
			input1.readOnly = true;
			attr_dev(input1, "id", "dust");
			attr_dev(input1, "class", "form-control");
			set_style(input1, "background", "#999");
			add_location(input1, file$2, 55, 6, 2615);
			attr_dev(div3, "class", "text-small");
			attr_dev(div3, "title", "Required for book keeping.");
			add_location(div3, file$2, 56, 6, 2735);
			attr_dev(div4, "class", "mt-5 col-12");
			add_location(div4, file$2, 50, 4, 2229);
			attr_dev(div5, "class", "row");
			add_location(div5, file$2, 37, 2, 1333);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div5, anchor);
			append_hydration_dev(div5, div2);
			append_hydration_dev(div2, label0);
			append_hydration_dev(label0, span0);
			append_hydration_dev(span0, t0);
			append_hydration_dev(label0, t1);
			append_hydration_dev(label0, span1);
			append_hydration_dev(div2, t2);
			append_hydration_dev(div2, input0);
			set_input_value(input0, /*pegAmount*/ ctx[1]);
			append_hydration_dev(div2, t3);
			append_hydration_dev(div2, div1);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, t4);
			append_hydration_dev(div1, t5);
			if (if_block) if_block.m(div1, null);
			append_hydration_dev(div5, t6);
			append_hydration_dev(div5, div4);
			append_hydration_dev(div4, label1);
			append_hydration_dev(label1, span2);
			append_hydration_dev(span2, t7);
			append_hydration_dev(label1, t8);
			append_hydration_dev(label1, span3);
			append_hydration_dev(div4, t9);
			append_hydration_dev(div4, input1);
			set_input_value(input1, /*amtData*/ ctx[0].dust);
			append_hydration_dev(div4, t10);
			append_hydration_dev(div4, div3);
			append_hydration_dev(div3, t11);
			append_hydration_dev(div5, t12);
			mount_component(feedisplay, div5, null);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(init.call(null, input0)),
					listen_dev(input0, "input", /*input0_input_handler*/ ctx[4]),
					listen_dev(input0, "input", /*input_handler*/ ctx[5], false, false, false, false),
					listen_dev(input1, "input", /*input1_input_handler*/ ctx[7])
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*amtData*/ 1) && t0_value !== (t0_value = /*amtData*/ ctx[0].label + "")) set_data_dev(t0, t0_value);

			if (dirty & /*pegAmount*/ 2 && to_number(input0.value) !== /*pegAmount*/ ctx[1]) {
				set_input_value(input0, /*pegAmount*/ ctx[1]);
			}

			if ((!current || dirty & /*amtData*/ 1) && t4_value !== (t4_value = /*amtData*/ ctx[0].info + "")) set_data_dev(t4, t4_value);

			if (/*amtData*/ ctx[0].change > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*amtData*/ 1 && to_number(input1.value) !== /*amtData*/ ctx[0].dust) {
				set_input_value(input1, /*amtData*/ ctx[0].dust);
			}

			const feedisplay_changes = {};
			if (dirty & /*amtData*/ 1) feedisplay_changes.amtData = /*amtData*/ ctx[0];
			if (dirty & /*pegAmount*/ 2) feedisplay_changes.currentPeg = /*pegAmount*/ ctx[1];
			feedisplay.$set(feedisplay_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(feedisplay.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(feedisplay.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			if (if_block) if_block.d();
			destroy_component(feedisplay);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function init(el) {
	el.focus();
}

function instance$2($$self, $$props, $$invalidate) {
	let low;
	let medium;
	let high;
	let $sbtcConfig;
	validate_store(sbtcConfig, 'sbtcConfig');
	component_subscribe($$self, sbtcConfig, $$value => $$invalidate(12, $sbtcConfig = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PegOutAmount', slots, []);
	let { amtData } = $$props;
	const dispatch = createEventDispatcher();
	let reason;
	let pegAmount = amtData.pegAmount;

	const changePegIn = maxValue => {
		reason = undefined;

		try {
			if (pegAmount > $sbtcConfig.balance.balance) {
				reason = 'Can\'t unwrap more sBTC then you own';

				dispatch('amount_updated', {
					opCode: 'user',
					error: true,
					reason: 'Can\'t unwrap more sBTC then you own'
				});

				return;
			}

			if (maxValue) {
				$$invalidate(1, pegAmount = $sbtcConfig.balance.balance);
			}

			const rate = amtData.fees.find(o => o === amtData.fee);

			dispatch('amount_updated', {
				opCode: 'user',
				error: false,
				newAmount: pegAmount,
				newFeeRate: rate
			});
		} catch(err) {
			reason = err || 'Amount is not valid';
		}
	};

	const changeRate = event => {
		const rate = event.detail.newFeeRate;

		dispatch('amount_updated', {
			opCode: 'prio',
			error: false,
			newAmount: pegAmount,
			newFeeRate: rate
		});
	};

	$$self.$$.on_mount.push(function () {
		if (amtData === undefined && !('amtData' in $$props || $$self.$$.bound[$$self.$$.props['amtData']])) {
			console.warn("<PegOutAmount> was created without expected prop 'amtData'");
		}
	});

	const writable_props = ['amtData'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PegOutAmount> was created with unknown prop '${key}'`);
	});

	function input0_input_handler() {
		pegAmount = to_number(this.value);
		$$invalidate(1, pegAmount);
	}

	const input_handler = () => changePegIn(false);
	const click_handler = () => changePegIn(true);

	function input1_input_handler() {
		amtData.dust = to_number(this.value);
		$$invalidate(0, amtData);
	}

	$$self.$$set = $$props => {
		if ('amtData' in $$props) $$invalidate(0, amtData = $$props.amtData);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		sbtcConfig,
		FeeDisplay,
		amtData,
		dispatch,
		reason,
		pegAmount,
		changePegIn,
		changeRate,
		init,
		high,
		medium,
		low,
		$sbtcConfig
	});

	$$self.$inject_state = $$props => {
		if ('amtData' in $$props) $$invalidate(0, amtData = $$props.amtData);
		if ('reason' in $$props) reason = $$props.reason;
		if ('pegAmount' in $$props) $$invalidate(1, pegAmount = $$props.pegAmount);
		if ('high' in $$props) high = $$props.high;
		if ('medium' in $$props) medium = $$props.medium;
		if ('low' in $$props) low = $$props.low;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*amtData*/ 1) {
			low = amtData.fee === amtData.fees[0];
		}

		if ($$self.$$.dirty & /*amtData*/ 1) {
			medium = amtData.fee === amtData.fees[1];
		}

		if ($$self.$$.dirty & /*amtData*/ 1) {
			high = amtData.fee === amtData.fees[2];
		}
	};

	return [
		amtData,
		pegAmount,
		changePegIn,
		changeRate,
		input0_input_handler,
		input_handler,
		click_handler,
		input1_input_handler
	];
}

class PegOutAmount extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, { amtData: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PegOutAmount",
			options,
			id: create_fragment$2.name
		});
	}

	get amtData() {
		throw new Error("<PegOutAmount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set amtData(value) {
		throw new Error("<PegOutAmount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const priv = utils.randomPrivateKey();
const keySetForFeeCalculation = [];
keySetForFeeCalculation.push({
  priv,
  ecdsaPub: getPublicKey(priv, true),
  schnorrPub: schnorr.getPublicKey(priv)
});
const _PegOutTransaction = class extends PegTransaction {
  constructor() {
    super();
    this.privKey = hex.decode("0101010101010101010101010101010101010101010101010101010101010101");
    this.getChange = () => {
      return this.maxCommit() - this.fee - this.dust;
    };
    this.setAmount = (amount) => {
      this.pegInData.amount = amount;
    };
    this.calculateFees = () => {
      if (!this.ready)
        throw new Error("Not ready!");
      const stacksAddress = "ST3N4AJFZZYC4BK99H53XP8KDGXFGQ2PRSPNET8TN";
      const sbtcWalletAddress = "tb1qasu5x7dllnejmx0dtd5j42quk4q03dl56caqss";
      const p2Ret = p2wpkh(keySetForFeeCalculation[0].ecdsaPub);
      assert$1("wpkh" === p2Ret.type);
      const tx = new Transaction({ allowUnknowOutput: true });
      for (const utxo of this.addressInfo.utxos) {
        if (this.isUTXOConfirmed(utxo)) {
          tx.addInput({
            txid: hex.decode(utxo.txid),
            //txid: utxo.txid,
            index: utxo.vout,
            witnessUtxo: {
              amount: 600n,
              script: p2wpkh(secp256k1.getPublicKey(this.privKey, true)).script
            }
          });
        } else {
          this.unconfirmedUtxos = true;
        }
      }
      if (tx.inputsLength === 0)
        throw new Error("No confirmed UTXOs (6 confirmations are required)");
      tx.addOutput({ script: Script.encode(["RETURN", Buffer.from(stacksAddress, "utf8")]), amount: 0n });
      tx.addOutputAddress(sbtcWalletAddress, BigInt(0), this.net);
      tx.addOutputAddress(this.fromBtcAddress, BigInt(0), this.net);
      tx.sign(this.privKey);
      tx.finalize();
      this.scureFee = Number(tx.fee);
      this.fees = [
        this.scureFee * 0.8,
        //Math.floor((this.feeInfo.low_fee_per_kb / 1000) * vsize),
        this.scureFee * 1,
        //Math.floor((this.feeInfo.medium_fee_per_kb / 1000) * vsize),
        this.scureFee * 1.2
        //Math.floor((this.feeInfo.high_fee_per_kb / 1000) * vsize),
      ];
      this.fee = this.fees[1];
      if (this.pegInData.amount === 0) {
        this.pegInData.amount = this.maxCommit() - this.fee;
      }
    };
    this.getOutputsForDisplay = () => {
      const changeAmount = Math.floor(this.maxCommit() - this.dust - this.fee);
      const addr = this.pegInData.stacksAddress || "stx address unknown";
      const outs = [
        { script: "RETURN " + Buffer.from(addr), amount: 0 },
        { address: this.pegInData.sbtcWalletAddress, amount: this.dust }
      ];
      if (changeAmount > 0)
        outs.push({ address: this.fromBtcAddress, amount: changeAmount });
      outs.push({ address: "pays " + this.fee + " satoshis to miner." });
      return outs;
    };
    this.getDataToSign = () => {
      const amtBuf = Buffer.alloc(9);
      amtBuf.writeUInt32LE(this.pegInData.amount, 0);
      const script = OutScript.encode(Address(this.net).decode(this.pegInData.sbtcWalletAddress));
      const scriptBuf = Buffer.from(script);
      const data = Buffer.concat([amtBuf, scriptBuf]);
      console.log("getDataToSign: " + data.toString("hex"));
      return data;
    };
    this.buildTransaction = (signature) => {
      if (!this.ready)
        throw new Error("Not ready!");
      if (!signature)
        throw new Error("Signature of output 2 scriptPubKey is required");
      console.log("buildTransaction:signature: ", signature.length + " : " + signature);
      return { opReturn: this.buildOpReturn(signature), opDrop: this.buildOpDrop(signature) };
    };
    this.addInputs = (tx) => {
      for (const utxo of this.addressInfo.utxos) {
        const script = RawTx.decode(hex.decode(utxo.tx.hex));
        tx.addInput({
          txid: hex.decode(utxo.txid),
          index: utxo.vout,
          witnessUtxo: {
            script: script.outputs[utxo.vout].script,
            amount: BigInt(utxo.value)
          }
        });
      }
    };
    this.buildOpReturn = (signature) => {
      if (!this.ready)
        throw new Error("Not ready!");
      if (!signature)
        throw new Error("Signature of output 2 scriptPubKey is required");
      const tx = new Transaction({ allowUnknowOutput: true });
      this.addInputs(tx);
      if (!signature)
        throw new Error("Signature of the amount and output 2 scriptPubKey is missing.");
      const data = this.buildData(signature);
      tx.addOutput({ script: Script.encode(["RETURN", data]), amount: 0n });
      tx.addOutputAddress(this.pegInData.sbtcWalletAddress, BigInt(this.dust), this.net);
      if (this.getChange() > 0)
        tx.addOutputAddress(this.fromBtcAddress, BigInt(this.getChange()), this.net);
      return tx;
    };
    this.buildOpDrop = (signature) => {
      if (!signature)
        throw new Error("Signature of the amount and output 2 scriptPubKey is missing.");
      const tx = new Transaction({ allowUnknowOutput: true });
      this.addInputs(tx);
      const asmScript = this.getOpDropP2shScript(signature);
      tx.addOutput({ script: asmScript, amount: BigInt(this.dust) });
      if (this.getChange() > 0)
        tx.addOutputAddress(this.fromBtcAddress, BigInt(this.getChange()), this.net);
      return tx;
    };
    this.buildData = (signature) => {
      const magicBuf = this.net === TEST_NETWORK ? Buffer.from(MAGIC_BYTES_TESTNET, "hex") : Buffer.from(MAGIC_BYTES_MAINNET, "hex");
      const opCodeBuf = Buffer.from(PEGOUT_OPCODE, "hex");
      const amtBuf = Buffer.allocUnsafe(9);
      amtBuf.writeUInt32LE(this.pegInData.amount, 0);
      const sigBuf = Buffer.from(signature, "hex");
      console.log("getOpDropP2shScript:signature : ", sigBuf.length);
      console.log("getOpDropP2shScript:signature : ", sigBuf.toString("hex"));
      const data = Buffer.concat([magicBuf, opCodeBuf, amtBuf, sigBuf]);
      console.log(data);
      console.log("getOpDropP2shScript:data : ", data.toString("hex"));
      return data;
    };
  }
  getOpDropP2shScript(signature) {
    const script = OutScript.encode(Address(this.net).decode(this.pegInData.sbtcWalletAddress));
    const data = this.buildData(signature);
    const asmScript = Script.encode([data, "DROP", "DUP", "HASH160", script, "EQUALVERIFY", "CHECKSIG"]);
    console.log("getOpDropP2shScript:asmScript: ", Script.decode(asmScript));
    return asmScript;
  }
};
let PegOutTransaction = _PegOutTransaction;
PegOutTransaction.create = async (network, fromBtcAddress, sbtcWalletAddress) => {
  const me = new _PegOutTransaction();
  me.net = network === "testnet" ? TEST_NETWORK : NETWORK;
  me.fromBtcAddress = fromBtcAddress;
  me.pegInData = {
    amount: 0,
    stacksAddress: void 0,
    sbtcWalletAddress
  };
  me.addressInfo = await fetchUtxoSet(fromBtcAddress);
  const btcFeeRates = await fetchCurrentFeeRates();
  me.feeInfo = btcFeeRates.feeInfo;
  me.ready = true;
  return me;
};
PegOutTransaction.hydrate = (o) => {
  const me = new _PegOutTransaction();
  me.net = o.net;
  if (!o.fromBtcAddress)
    throw new Error("No address - use create instead!");
  me.fromBtcAddress = o.fromBtcAddress;
  me.pegInData = o.pegInData;
  me.addressInfo = o.addressInfo;
  me.feeInfo = o.feeInfo;
  me.fees = o.fees;
  me.fee = o.fee;
  me.scureFee = o.scureFee;
  me.ready = o.ready;
  return me;
};

function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!isLE)
    throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}

// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
    }
    update(data) {
        assert.exists(this);
        const { view, buffer, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = createView(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        assert.exists(this);
        assert.output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = createView(out);
        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}

// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
const Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f$1(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = new Uint32Array(16);
class RIPEMD160 extends SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl(al + f$1(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl(ar + f$1(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
const ripemd160 = wrapConstructor(() => new RIPEMD160());

function U(r){let t=r.reduce((i,o)=>i+o.length,0),e=new Uint8Array(t),n=0;for(let i=0;i<r.length;i++)e.set(r[i],n),n+=r[i].length;return e}function lr(r){return typeof r=="object"&&(r=Uint8Array.from(r)),r}var O=new Array(255);for(let r=0;r<=255;++r)O[r]=r.toString(16).padStart(2,"0");function l(r){if(typeof r!="string")throw new TypeError("hexToBytes: expected string, got "+typeof r);if(r.length%2)throw new Error(`hexToBytes: received invalid unpadded hex, got: ${r.length}`);let t=new Uint8Array(r.length/2);for(let e=0;e<t.length;e++){let n=e*2;t[e]=Number.parseInt(r.slice(n,n+2),16);}return t}function p(r){let t=new Array(r.length);for(let e=0;e<r.length;++e)t[e]=O[r[e]];return t.join("")}var Ir=r=>typeof r=="string"?l(r):r;BigInt(0);BigInt(1);BigInt(58);var ur=(e=>(e[e.Testnet=2147483648]="Testnet",e[e.Mainnet=1]="Mainnet",e))(ur||{}),ar=(e=>(e[e.Mainnet=0]="Mainnet",e[e.Testnet=128]="Testnet",e))(ar||{});/*! micro-base58 - MIT License (c) 2021, Paul Miller (https://paulmillr.com) */

// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
const sha256 = wrapConstructor(() => new SHA256());

const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};

// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = u64.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n)));
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = new Uint32Array(80);
const SHA512_W_L = new Uint32Array(80);
class SHA512 extends SHA2 {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
wrapConstructor(() => new SHA512());
wrapConstructor(() => new SHA512_256());
wrapConstructor(() => new SHA384());

function f(r){return sha256.create().update(lr(r)).digest()}

/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _3n = BigInt(3);
const _8n = BigInt(8);
const POW_2_256 = _2n ** BigInt(256);
const CURVE = {
    a: _0n,
    b: BigInt(7),
    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),
    n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),
    h: _1n,
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
};
function weistrass(x) {
    const { a, b } = CURVE;
    const x2 = mod(x * x);
    const x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
}
const USE_ENDOMORPHISM = CURVE.a === _0n;
class JacobianPoint {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    static fromAffine(p) {
        if (!(p instanceof Point)) {
            throw new TypeError('JacobianPoint#fromAffine: expected Point');
        }
        return new JacobianPoint(p.x, p.y, _1n);
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
    equals(other) {
        if (!(other instanceof JacobianPoint))
            throw new TypeError('JacobianPoint expected');
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod(Z1 ** _2n);
        const Z2Z2 = mod(Z2 ** _2n);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
    }
    negate() {
        return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
    double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod(X1 ** _2n);
        const B = mod(Y1 ** _2n);
        const C = mod(B ** _2n);
        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));
        const E = mod(_3n * A);
        const F = mod(E ** _2n);
        const X3 = mod(F - _2n * D);
        const Y3 = mod(E * (D - X3) - _8n * C);
        const Z3 = mod(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
        if (!(other instanceof JacobianPoint))
            throw new TypeError('JacobianPoint expected');
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n)
            return this;
        if (X1 === _0n || Y1 === _0n)
            return other;
        const Z1Z1 = mod(Z1 ** _2n);
        const Z2Z2 = mod(Z2 ** _2n);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r = mod(S2 - S1);
        if (H === _0n) {
            if (r === _0n) {
                return this.double();
            }
            else {
                return JacobianPoint.ZERO;
            }
        }
        const HH = mod(H ** _2n);
        const HHH = mod(H * HH);
        const V = mod(U1 * HH);
        const X3 = mod(r ** _2n - HHH - _2n * V);
        const Y3 = mod(r * (V - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === 'bigint' && scalar === _0n)
            return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n)
            return this;
        if (!USE_ENDOMORPHISM) {
            let p = P0;
            let d = this;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        }
        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
                k1p = k1p.add(d);
            if (k2 & _1n)
                k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
        }
        if (k1neg)
            k1p = k1p.negate();
        if (k2neg)
            k2p = k2p.negate();
        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
    }
    precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            for (let i = 1; i < 2 ** (W - 1); i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE))
            affinePoint = Point.BASE;
        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
        if (256 % W) {
            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = JacobianPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.ZERO;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
            }
            if (wbits === 0) {
                let pr = precomputes[offset];
                if (window % 2)
                    pr = pr.negate();
                f = f.add(pr);
            }
            else {
                let cached = precomputes[offset + Math.abs(wbits) - 1];
                if (wbits < 0)
                    cached = cached.negate();
                p = p.add(cached);
            }
        }
        return { p, f };
    }
    multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
        }
        else {
            const { p, f } = this.wNAF(n, affinePoint);
            point = p;
            fake = f;
        }
        return JacobianPoint.normalizeZ([point, fake])[0];
    }
    toAffine(invZ = invert(this.z)) {
        const { x, y, z } = this;
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x * iz2);
        const ay = mod(y * iz3);
        const zz = mod(z * iz1);
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return new Point(ax, ay);
    }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
const pointPrecomputes = new WeakMap();
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x))
            throw new Error('Point is not on curve');
        const y2 = weistrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n) === _1n;
        if (isShort) {
            if (isYOdd)
                y = mod(-y);
        }
        else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd)
                y = mod(-y);
        }
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromUncompressedHex(bytes) {
        const x = bytesToNumber(bytes.subarray(1, 33));
        const y = bytesToNumber(bytes.subarray(33, 65));
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {
            return this.fromCompressedHex(bytes);
        }
        if (len === 65 && header === 0x04)
            return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
        msgHash = ensureBytes(msgHash);
        const h = truncateHash(msgHash);
        const { r, s } = normalizeSignature(signature);
        if (recovery !== 0 && recovery !== 1) {
            throw new Error('Cannot recover signature: invalid recovery bit');
        }
        const prefix = recovery & 1 ? '03' : '02';
        const R = Point.fromHex(prefix + numTo32bStr(r));
        const { n } = CURVE;
        const rinv = invert(r, n);
        const u1 = mod(-h * rinv, n);
        const u2 = mod(s * rinv, n);
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
            throw new Error('Cannot recover signature: point at infinify');
        Q.assertValidity();
        return Q;
    }
    toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
            const prefix = this.y & _1n ? '03' : '02';
            return `${prefix}${x}`;
        }
        else {
            return `04${x}${numTo32bStr(this.y)}`;
        }
    }
    toHexX() {
        return this.toHex(true).slice(2);
    }
    toRawX() {
        return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
        const msg = 'Point is not on elliptic curve';
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y))
            throw new Error(msg);
        const left = mod(y * y);
        const right = weistrass(x);
        if (mod(left - right) !== _0n)
            throw new Error(msg);
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point(this.x, mod(-this.y));
    }
    double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
}
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
}
function parseDERInt(data) {
    if (data.length < 2 || data[0] !== 0x02) {
        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
    }
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len) {
        throw new Error(`Invalid signature integer: wrong length`);
    }
    if (res[0] === 0x00 && res[1] <= 0x7f) {
        throw new Error('Invalid signature integer: trailing length');
    }
    return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
    if (data.length < 2 || data[0] != 0x30) {
        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
    }
    if (data[1] !== data.length - 2) {
        throw new Error('Invalid signature: incorrect length');
    }
    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
    if (rBytesLeft.length) {
        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
    }
    return { r, s };
}
class Signature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromCompact(hex) {
        const arr = isUint8a(hex);
        const name = 'Signature.fromCompact';
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128)
            throw new Error(`${name}: Expected 64-byte hex`);
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
    static fromDER(hex) {
        const arr = isUint8a(hex);
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
    }
    static fromHex(hex) {
        return this.fromDER(hex);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
            throw new Error('Invalid Signature: r must be 0 < r < n');
        if (!isWithinCurveOrder(s))
            throw new Error('Invalid Signature: s must be 0 < s < n');
    }
    hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
    }
    normalizeS() {
        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
    }
    toDERRawBytes(isCompressed = false) {
        return hexToBytes(this.toDERHex(isCompressed));
    }
    toDERHex(isCompressed = false) {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        if (isCompressed)
            return sHex;
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const rLen = numberToHexUnpadded(rHex.length / 2);
        const sLen = numberToHexUnpadded(sHex.length / 2);
        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
        return this.toDERRawBytes();
    }
    toHex() {
        return this.toDERHex();
    }
    toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
}
function isUint8a(bytes) {
    return bytes instanceof Uint8Array;
}
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
function numTo32bStr(num) {
    if (num > POW_2_256)
        throw new Error('Expected number < 2^256');
    return num.toString(16).padStart(64, '0');
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);
    }
    return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
function bytesToNumber(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)
        return BigInt(num);
    if (typeof num === 'bigint' && isWithinCurveOrder(num))
        return num;
    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
}
function mod(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= P;
    }
    return res;
}
function sqrtMod(x) {
    const { P } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = (x * x * x) % P;
    const b3 = (b2 * b2 * x) % P;
    const b6 = (pow2(b3, _3n) * b3) % P;
    const b9 = (pow2(b6, _3n) * b3) % P;
    const b11 = (pow2(b9, _2n) * b2) % P;
    const b22 = (pow2(b11, _11n) * b11) % P;
    const b44 = (pow2(b22, _22n) * b22) % P;
    const b88 = (pow2(b44, _44n) * b44) % P;
    const b176 = (pow2(b88, _88n) * b88) % P;
    const b220 = (pow2(b176, _44n) * b44) % P;
    const b223 = (pow2(b220, _3n) * b3) % P;
    const t1 = (pow2(b223, _23n) * b22) % P;
    const t2 = (pow2(t1, _6n) * b2) % P;
    return pow2(t2, _2n);
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, u = _1n;
    while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        b = a, a = r, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n)
            return acc;
        scratch[i] = acc;
        return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
        if (num === _0n)
            return acc;
        scratch[i] = mod(acc * scratch[i], p);
        return mod(acc * num, p);
    }, inverted);
    return scratch;
}
const divNearest = (a, b) => (a + b / _2n) / b;
const POW_2_128 = _2n ** BigInt(128);
function splitScalarEndo(k) {
    const { n } = CURVE;
    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
    const b2 = a1;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = mod(k - c1 * a1 - c2 * a2, n);
    let k2 = mod(-c1 * b1 - c2 * b2, n);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg)
        k1 = n - k1;
    if (k2neg)
        k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
    }
    return { k1neg, k1, k2neg, k2 };
}
function truncateHash(hash) {
    const { n } = CURVE;
    const byteLength = hash.length;
    const delta = byteLength * 8 - 256;
    let h = bytesToNumber(hash);
    if (delta > 0)
        h = h >> BigInt(delta);
    if (h >= n)
        h -= n;
    return h;
}
function isWithinCurveOrder(num) {
    return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
    return _0n < num && num < CURVE.P;
}
function normalizePrivateKey(key) {
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
        num = BigInt(key);
    }
    else if (typeof key === 'string') {
        if (key.length !== 64)
            throw new Error('Expected 32 bytes of private key');
        num = hexToNumber(key);
    }
    else if (isUint8a(key)) {
        if (key.length !== 32)
            throw new Error('Expected 32 bytes of private key');
        num = bytesToNumber(key);
    }
    else {
        throw new TypeError('Expected valid private key');
    }
    if (!isWithinCurveOrder(num))
        throw new Error('Expected private key: 0 < key < n');
    return num;
}
function normalizeSignature(signature) {
    if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
    }
    try {
        return Signature.fromDER(signature);
    }
    catch (error) {
        return Signature.fromCompact(signature);
    }
}
Point.BASE._setWindowSize(8);

function E(t){return typeof t=="string"?ripemd160(t):ripemd160.create().update(lr(t)).digest()}var L=class{digest(e){return E(e)}};function Ce(){return new L}function P(t){return Ce().digest(t)}var X=(o=>(o[o.mainnetP2PKH=22]="mainnetP2PKH",o[o.mainnetP2SH=20]="mainnetP2SH",o[o.testnetP2PKH=26]="testnetP2PKH",o[o.testnetP2SH=21]="testnetP2SH",o))(X||{}),y="0123456789ABCDEFGHJKMNPQRSTVWXYZ",R=new Map;[...y].forEach((t,e)=>R.set(t,e));var H="0123456789abcdef",j=new Map;[...H].forEach((t,e)=>j.set(t,e));function V(t,e){let r=Y(t,e),n=Me(U([e,r]));return `S${y[t]}${n}`}function Me(t){let e=p(t),r=[],n=0;for(let s=e.length-1;s>=0;s--)if(n<4){let p=j.get(e[s])>>n,a=0;s!==0&&(a=j.get(e[s-1]));let f=1+n,d=a%(1<<f)<<5-f,u=y[p+d];n=f,r.unshift(u);}else n=0;let o=0;for(let s=0;s<r.length&&r[s]==="0";s++)o++;r=r.slice(o);let i=/^\u0000*/.exec(new TextDecoder().decode(t)),c=i?i[0].length:0;for(let s=0;s<c;s++)r.unshift(y[0]);return r.join("")}function Y(t,e){let r=f(U([Uint8Array.of(t),e]));return f(r).slice(0,4)}function qe(t,e=22){return V(e,m(Ir(t)))}function m(t){let e=f(t);return P(e)}

tupleCV({
  name: stringAsciiCV("SBTC Bridge"),
  version: stringAsciiCV("1.0.0"),
  "chain-id": uintCV(1 /* Mainnet */  /* Testnet */)
});
function verifyDataSignature(message, publicKey, signature) {
  return verifyMessageSignature({
    message: message.toString("hex"),
    signature,
    publicKey
  });
}
function getStacksAddressFromSignature(message, signature) {
  const msgHash = hashMessage(message);
  let pubkey = recoverPublicKey(msgHash, signature, 1, true);
  pubkey = bytesToHex$1(pubkey);
  const addresses = {
    tp2pkh: qe(pubkey, X.testnetP2PKH),
    tp2sh: qe(pubkey, X.testnetP2SH),
    mp2pkh: qe(pubkey, X.mainnetP2PKH),
    mp2sh: qe(pubkey, X.mainnetP2SH)
  };
  return addresses;
}

const BuildTransaction_svelte_svelte_type_style_lang = '';

/* src/lib/components/unwrapper/BuildTransaction.svelte generated by Svelte v3.57.0 */
const file$1 = "src/lib/components/unwrapper/BuildTransaction.svelte";

// (142:0) {:else}
function create_else_block_1(ctx) {
	let div;
	let p0;
	let t0;
	let t1;
	let p1;
	let span1;
	let t2;
	let span0;
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			p0 = element("p");
			t0 = text("Problem Connecting to APIs");
			t1 = space();
			p1 = element("p");
			span1 = element("span");
			t2 = text("Status: Bridge API currently experiencing connectivity problems.\n    We are already working on this.\n  ");
			span0 = element("span");
			t3 = text("Please report this to the core engineering team!");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			p0 = claim_element(div_nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t0 = claim_text(p0_nodes, "Problem Connecting to APIs");
			p0_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			p1 = claim_element(div_nodes, "P", {});
			var p1_nodes = children(p1);
			span1 = claim_element(p1_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t2 = claim_text(span1_nodes, "Status: Bridge API currently experiencing connectivity problems.\n    We are already working on this.\n  ");
			span0 = claim_element(span1_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t3 = claim_text(span0_nodes, "Please report this to the core engineering team!");
			span0_nodes.forEach(detach_dev);
			span1_nodes.forEach(detach_dev);
			p1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p0, "class", "text-white");
			add_location(p0, file$1, 143, 2, 5264);
			attr_dev(span0, "class", "mt-5 text-warning");
			add_location(span0, file$1, 146, 2, 5448);
			attr_dev(span1, "class", "nav-item");
			add_location(span1, file$1, 144, 5, 5322);
			add_location(p1, file$1, 144, 2, 5319);
			attr_dev(div, "class", "lobby bg-dark");
			add_location(div, file$1, 142, 0, 5234);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, p0);
			append_hydration_dev(p0, t0);
			append_hydration_dev(div, t1);
			append_hydration_dev(div, p1);
			append_hydration_dev(p1, span1);
			append_hydration_dev(span1, t2);
			append_hydration_dev(span1, span0);
			append_hydration_dev(span0, t3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(142:0) {:else}",
		ctx
	});

	return block;
}

// (119:0) {#if ready}
function create_if_block$1(ctx) {
	let div;
	let utxoselection;
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let if_block1_anchor;
	let current;

	utxoselection = new UTXOSelection({
			props: { utxoData: /*utxoData*/ ctx[5] },
			$$inline: true
		});

	utxoselection.$on("utxo_updated", /*utxoUpdated*/ ctx[12]);
	const if_block_creators = [create_if_block_2$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*$sbtcConfig*/ ctx[1].balance.balance <= 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*errorReason*/ ctx[0] && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(utxoselection.$$.fragment);
			t0 = space();
			if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(utxoselection.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "mb-4");
			add_location(div, file$1, 119, 2, 4314);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(utxoselection, div, null);
			insert_hydration_dev(target, t0, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const utxoselection_changes = {};
			if (dirty & /*utxoData*/ 32) utxoselection_changes.utxoData = /*utxoData*/ ctx[5];
			utxoselection.$set(utxoselection_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(t1.parentNode, t1);
			}

			if (/*errorReason*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$1(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(utxoselection.$$.fragment, local);
			transition_in(if_block0);
			current = true;
		},
		o: function outro(local) {
			transition_out(utxoselection.$$.fragment, local);
			transition_out(if_block0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(utxoselection);
			if (detaching) detach_dev(t0);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(119:0) {#if ready}",
		ctx
	});

	return block;
}

// (126:2) {:else}
function create_else_block$1(ctx) {
	let t0;
	let t1;
	let if_block2_anchor;
	let current;
	let if_block0 = /*showStxAddress*/ ctx[4] && create_if_block_5(ctx);
	let if_block1 = /*showAmount*/ ctx[3] && create_if_block_4(ctx);
	let if_block2 = /*showButton*/ ctx[2] && create_if_block_3(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t1 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			if_block2_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration_dev(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_hydration_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*showStxAddress*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*showStxAddress*/ 16) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*showAmount*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*showAmount*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*showButton*/ ctx[2]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_3(ctx);
					if_block2.c();
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t1);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(126:2) {:else}",
		ctx
	});

	return block;
}

// (121:2) {#if $sbtcConfig.balance.balance <= 0}
function create_if_block_2$1(ctx) {
	let div;
	let p0;
	let t0;
	let a0;
	let t1_value = /*$sbtcConfig*/ ctx[1].balance.address + "";
	let t1;
	let a0_href_value;
	let t2;
	let p1;
	let a1;
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			p0 = element("p");
			t0 = text("No SBTC to unwrap for account: ");
			a0 = element("a");
			t1 = text(t1_value);
			t2 = space();
			p1 = element("p");
			a1 = element("a");
			t3 = text("Get sBTC here!");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			p0 = claim_element(div_nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t0 = claim_text(p0_nodes, "No SBTC to unwrap for account: ");
			a0 = claim_element(p0_nodes, "A", { href: true });
			var a0_nodes = children(a0);
			t1 = claim_text(a0_nodes, t1_value);
			a0_nodes.forEach(detach_dev);
			p0_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			p1 = claim_element(div_nodes, "P", {});
			var p1_nodes = children(p1);
			a1 = claim_element(p1_nodes, "A", { href: true });
			var a1_nodes = children(a1);
			t3 = claim_text(a1_nodes, "Get sBTC here!");
			a1_nodes.forEach(detach_dev);
			p1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a0, "href", a0_href_value = explorerAddressUrl(/*$sbtcConfig*/ ctx[1].balance.address));
			add_location(a0, file$1, 122, 51, 4535);
			attr_dev(p0, "class", "mb-4");
			add_location(p0, file$1, 122, 4, 4488);
			attr_dev(a1, "href", "" + (base + "/wrap"));
			add_location(a1, file$1, 123, 7, 4638);
			add_location(p1, file$1, 123, 4, 4635);
			attr_dev(div, "class", "text-center text-warning my-5");
			add_location(div, file$1, 121, 2, 4440);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, p0);
			append_hydration_dev(p0, t0);
			append_hydration_dev(p0, a0);
			append_hydration_dev(a0, t1);
			append_hydration_dev(div, t2);
			append_hydration_dev(div, p1);
			append_hydration_dev(p1, a1);
			append_hydration_dev(a1, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$sbtcConfig*/ 2 && t1_value !== (t1_value = /*$sbtcConfig*/ ctx[1].balance.address + "")) set_data_dev(t1, t1_value);

			if (dirty & /*$sbtcConfig*/ 2 && a0_href_value !== (a0_href_value = explorerAddressUrl(/*$sbtcConfig*/ ctx[1].balance.address))) {
				attr_dev(a0, "href", a0_href_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(121:2) {#if $sbtcConfig.balance.balance <= 0}",
		ctx
	});

	return block;
}

// (127:2) {#if showStxAddress}
function create_if_block_5(ctx) {
	let div;
	let principal;
	let current;

	principal = new Principal({
			props: { principalData: /*principalData*/ ctx[7] },
			$$inline: true
		});

	principal.$on("principal_updated", /*principalUpdated*/ ctx[11]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(principal.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(principal.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "mb-4");
			add_location(div, file$1, 127, 2, 4727);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(principal, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(principal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(principal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(principal);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(127:2) {#if showStxAddress}",
		ctx
	});

	return block;
}

// (130:2) {#if showAmount}
function create_if_block_4(ctx) {
	let div;
	let pegoutamount;
	let current;

	pegoutamount = new PegOutAmount({
			props: { amtData: /*amtData*/ ctx[6] },
			$$inline: true
		});

	pegoutamount.$on("amount_updated", /*amountUpdated*/ ctx[10]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(pegoutamount.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(pegoutamount.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "mb-4");
			add_location(div, file$1, 130, 2, 4850);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(pegoutamount, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const pegoutamount_changes = {};
			if (dirty & /*amtData*/ 64) pegoutamount_changes.amtData = /*amtData*/ ctx[6];
			pegoutamount.$set(pegoutamount_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pegoutamount.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pegoutamount.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(pegoutamount);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(130:2) {#if showAmount}",
		ctx
	});

	return block;
}

// (133:2) {#if showButton}
function create_if_block_3(ctx) {
	let div1;
	let div0;
	let button;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			button = element("button");
			t = text("CONTINUE");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			button = claim_element(div0_nodes, "BUTTON", { class: true, type: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "CONTINUE");
			button_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "btn btn-outline-info w-100");
			attr_dev(button, "type", "button");
			add_location(button, file$1, 135, 6, 5010);
			attr_dev(div0, "class", "col");
			add_location(div0, file$1, 134, 4, 4986);
			attr_dev(div1, "class", "row s-DXQTMplg7quh");
			add_location(div1, file$1, 133, 2, 4964);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, button);
			append_hydration_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[16], false, false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(133:2) {#if showButton}",
		ctx
	});

	return block;
}

// (141:2) {#if errorReason}
function create_if_block_1$1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*errorReason*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*errorReason*/ ctx[0]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "text-danger");
			add_location(div, file$1, 140, 19, 5176);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errorReason*/ 1) set_data_dev(t, /*errorReason*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(141:2) {#if errorReason}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*ready*/ ctx[8]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let amtData;
	let utxoData;
	let showStxAddress;
	let showAmount;
	let showButton;
	let $sbtcConfig;
	validate_store(sbtcConfig, 'sbtcConfig');
	component_subscribe($$self, sbtcConfig, $$value => $$invalidate(1, $sbtcConfig = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BuildTransaction', slots, []);
	let { poTx } = $$props;
	if (!poTx.fromBtcAddress) poTx.fromBtcAddress = addresses().cardinal;
	if (!poTx.pegInData.stacksAddress && addresses().stxAddress) poTx.pegInData.stacksAddress = addresses().stxAddress;

	const principalData = {
		label: 'Stacks Contract or Account Address',
		info: 'sBTC will be burned from this account',
		currentAddress: poTx.pegInData.stacksAddress
	};

	const network = "mainnet";
	const dispatch = createEventDispatcher();
	let ready = true;
	let errorReason;
	let stxAddressOk = true;
	let amountOk = true;

	const updateConfig = () => {
		const conf = $sbtcConfig;
		conf.pegOutTransaction = poTx;
		sbtcConfig.update(() => conf);
		$$invalidate(15, amountOk = poTx.pegInData.amount > 0);
	};

	const requestSignature = () => {
		const script = poTx.getDataToSign();
		signMessage(requestSignatureCB, script);
	};

	const requestSignatureCB = async (sigData, message) => {
		//const msg = { script: script.toString('hex') }
		//const sigData:any = await requestSignMessage(msg);
		message.toString('hex');

		//const valid = verifyDataSignature(message, sigData.publicKey, sigData.signature)
		//const addreObj = getStacksAddressFromSignature(message.toString('hex'), sigData.signature)
		const conf = $sbtcConfig;

		conf.sigData = sigData;
		sbtcConfig.update(() => conf);
		dispatch('request_signature');
	};

	const amountUpdated = event => {
		$$invalidate(15, amountOk = !event.detail.error);

		if (amountOk) {
			poTx.setFeeRate(event.detail.newFeeRate);
			poTx.setAmount(event.detail.newAmount);
			updateConfig();
		} else {
			$$invalidate(0, errorReason = event.detail.reason);
		}
	};

	const principalUpdated = event => {
		$$invalidate(14, stxAddressOk = !event.detail.error);

		if (stxAddressOk) {
			poTx.setStacksAddress(event.detail.currentAddress);
			updateConfig();
		}
	};

	const utxoUpdated = async event => {
		$$invalidate(0, errorReason = undefined);
		const data = event.detail;

		if (data.opCode === 'address-change') {
			try {
				const p0 = poTx?.pegInData;
				$$invalidate(13, poTx = await PegOutTransaction.create(network, data.bitcoinAddress, $sbtcConfig.sbtcContractData.sbtcWalletAddress));
				poTx.calculateFees();
				if (p0.amount > 0 && p0.amount < poTx.maxCommit()) poTx.setAmount(p0.amount);
				updateConfig();
			} catch(err) {
				if (err.message !== 'No inputs signed') $$invalidate(0, errorReason = err.message); else $$invalidate(0, errorReason = 'Please fix above errors and try again.');
			}
		}
	};

	onMount(async () => {
		if (!poTx.pegInData.stacksAddress) $$invalidate(14, stxAddressOk = false);
		if (poTx.pegInData.amount > 0) $$invalidate(15, amountOk = true);
		updateConfig();
	});

	$$self.$$.on_mount.push(function () {
		if (poTx === undefined && !('poTx' in $$props || $$self.$$.bound[$$self.$$.props['poTx']])) {
			console.warn("<BuildTransaction> was created without expected prop 'poTx'");
		}
	});

	const writable_props = ['poTx'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BuildTransaction> was created with unknown prop '${key}'`);
	});

	const click_handler = () => requestSignature();

	$$self.$$set = $$props => {
		if ('poTx' in $$props) $$invalidate(13, poTx = $$props.poTx);
	};

	$$self.$capture_state = () => ({
		onMount,
		sbtcConfig,
		Principal,
		PegOutAmount,
		UTXOSelection,
		createEventDispatcher,
		PegOutTransaction,
		base,
		explorerAddressUrl,
		verifyDataSignature,
		getStacksAddressFromSignature,
		addresses,
		signMessage,
		poTx,
		principalData,
		network,
		dispatch,
		ready,
		errorReason,
		stxAddressOk,
		amountOk,
		updateConfig,
		requestSignature,
		requestSignatureCB,
		amountUpdated,
		principalUpdated,
		utxoUpdated,
		showButton,
		showAmount,
		showStxAddress,
		utxoData,
		amtData,
		$sbtcConfig
	});

	$$self.$inject_state = $$props => {
		if ('poTx' in $$props) $$invalidate(13, poTx = $$props.poTx);
		if ('ready' in $$props) $$invalidate(8, ready = $$props.ready);
		if ('errorReason' in $$props) $$invalidate(0, errorReason = $$props.errorReason);
		if ('stxAddressOk' in $$props) $$invalidate(14, stxAddressOk = $$props.stxAddressOk);
		if ('amountOk' in $$props) $$invalidate(15, amountOk = $$props.amountOk);
		if ('showButton' in $$props) $$invalidate(2, showButton = $$props.showButton);
		if ('showAmount' in $$props) $$invalidate(3, showAmount = $$props.showAmount);
		if ('showStxAddress' in $$props) $$invalidate(4, showStxAddress = $$props.showStxAddress);
		if ('utxoData' in $$props) $$invalidate(5, utxoData = $$props.utxoData);
		if ('amtData' in $$props) $$invalidate(6, amtData = $$props.amtData);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*poTx, $sbtcConfig*/ 8194) {
			$$invalidate(6, amtData = {
				pegIn: false,
				label: 'Amount (SBTC)',
				info: 'The amount to unwrap cannot exceed your sBTC balance',
				pegAmount: poTx.pegInData.amount > 0
				? poTx.pegInData.amount
				: $sbtcConfig.balance.balance,
				maxCommit: poTx.maxCommit(),
				change: poTx.getChange(),
				fee: poTx.fee,
				fees: poTx.fees,
				dust: poTx.dust
			});
		}

		if ($$self.$$.dirty & /*poTx*/ 8192) {
			$$invalidate(5, utxoData = {
				label: 'Your Bitcoin Address',
				info: 'Your sBTC will be burned and the equivalent bitcoin then sent to this address',
				utxos: poTx.addressInfo.utxos,
				maxCommit: poTx.ready ? poTx.maxCommit() : 0,
				fromBtcAddress: poTx.ready ? poTx.fromBtcAddress : addresses().cardinal,
				numbInputs: poTx.ready ? poTx.addressInfo.utxos.length : 0,
				network
			});
		}

		if ($$self.$$.dirty & /*poTx, errorReason*/ 8193) {
			$$invalidate(4, showStxAddress = poTx.ready && !errorReason);
		}

		if ($$self.$$.dirty & /*poTx, stxAddressOk, errorReason*/ 24577) {
			$$invalidate(3, showAmount = poTx.ready && stxAddressOk && !errorReason);
		}

		if ($$self.$$.dirty & /*poTx, amountOk, errorReason*/ 40961) {
			$$invalidate(2, showButton = poTx.ready && amountOk && !errorReason);
		}
	};

	return [
		errorReason,
		$sbtcConfig,
		showButton,
		showAmount,
		showStxAddress,
		utxoData,
		amtData,
		principalData,
		ready,
		requestSignature,
		amountUpdated,
		principalUpdated,
		utxoUpdated,
		poTx,
		stxAddressOk,
		amountOk,
		click_handler
	];
}

class BuildTransaction extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, { poTx: 13 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BuildTransaction",
			options,
			id: create_fragment$1.name
		});
	}

	get poTx() {
		throw new Error("<BuildTransaction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set poTx(value) {
		throw new Error("<BuildTransaction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const _page_svelte_svelte_type_style_lang = '';

/* src/routes/unwrap/+page.svelte generated by Svelte v3.57.0 */
const file = "src/routes/unwrap/+page.svelte";

// (44:7) {:else}
function create_else_block(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*sigData*/ ctx[1] && !/*sigData*/ ctx[1].webWallet && create_if_block_2(ctx);
	let if_block1 = /*sigData*/ ctx[1] && /*sigData*/ ctx[1].webWallet && create_if_block_1(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*sigData*/ ctx[1] && !/*sigData*/ ctx[1].webWallet) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*sigData*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*sigData*/ ctx[1] && /*sigData*/ ctx[1].webWallet) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*sigData*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(44:7) {:else}",
		ctx
	});

	return block;
}

// (42:7) {#if view === 'build_tx_view'}
function create_if_block(ctx) {
	let buildtransaction;
	let current;

	buildtransaction = new BuildTransaction({
			props: { poTx: /*poTx*/ ctx[0] },
			$$inline: true
		});

	buildtransaction.$on("request_signature", /*openSigView*/ ctx[3]);

	const block = {
		c: function create() {
			create_component(buildtransaction.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(buildtransaction.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(buildtransaction, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const buildtransaction_changes = {};
			if (dirty & /*poTx*/ 1) buildtransaction_changes.poTx = /*poTx*/ ctx[0];
			buildtransaction.$set(buildtransaction_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(buildtransaction.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(buildtransaction.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(buildtransaction, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(42:7) {#if view === 'build_tx_view'}",
		ctx
	});

	return block;
}

// (45:8) {#if sigData && !sigData.webWallet}
function create_if_block_2(ctx) {
	let signtransaction;
	let current;

	signtransaction = new SignTransaction({
			props: {
				sigData: /*sigData*/ ctx[1],
				pegInfo: JSON.parse(JSON.stringify(/*poTx*/ ctx[0]))
			},
			$$inline: true
		});

	signtransaction.$on("update_transaction", /*updateTransaction*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(signtransaction.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(signtransaction.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(signtransaction, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const signtransaction_changes = {};
			if (dirty & /*sigData*/ 2) signtransaction_changes.sigData = /*sigData*/ ctx[1];
			if (dirty & /*poTx*/ 1) signtransaction_changes.pegInfo = JSON.parse(JSON.stringify(/*poTx*/ ctx[0]));
			signtransaction.$set(signtransaction_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(signtransaction.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(signtransaction.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(signtransaction, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(45:8) {#if sigData && !sigData.webWallet}",
		ctx
	});

	return block;
}

// (48:6) {#if sigData && sigData.webWallet}
function create_if_block_1(ctx) {
	let signtransactionweb;
	let current;

	signtransactionweb = new SignTransactionWeb({
			props: {
				sigData: /*sigData*/ ctx[1],
				pegInfo: JSON.parse(JSON.stringify(/*poTx*/ ctx[0]))
			},
			$$inline: true
		});

	signtransactionweb.$on("update_transaction", /*updateTransaction*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(signtransactionweb.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(signtransactionweb.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(signtransactionweb, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const signtransactionweb_changes = {};
			if (dirty & /*sigData*/ 2) signtransactionweb_changes.sigData = /*sigData*/ ctx[1];
			if (dirty & /*poTx*/ 1) signtransactionweb_changes.pegInfo = JSON.parse(JSON.stringify(/*poTx*/ ctx[0]));
			signtransactionweb.$set(signtransactionweb_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(signtransactionweb.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(signtransactionweb.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(signtransactionweb, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(48:6) {#if sigData && sigData.webWallet}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let section;
	let div5;
	let div4;
	let h1;
	let t0;
	let span;
	let t1;
	let t2;
	let h2;
	let t3;
	let t4;
	let div0;
	let sbtcwalletdisplay;
	let t5;
	let div3;
	let div2;
	let div1;
	let current_block_type_index;
	let if_block;
	let current;
	sbtcwalletdisplay = new SbtcWalletDisplay({ $$inline: true });
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*view*/ ctx[2] === 'build_tx_view') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			section = element("section");
			div5 = element("div");
			div4 = element("div");
			h1 = element("h1");
			t0 = text("Unwrap ");
			span = element("span");
			t1 = text("sBTC");
			t2 = space();
			h2 = element("h2");
			t3 = text("sBTC to BTC");
			t4 = space();
			div0 = element("div");
			create_component(sbtcwalletdisplay.$$.fragment);
			t5 = space();
			div3 = element("div");
			div2 = element("div");
			div1 = element("div");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div5 = claim_element(section_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			h1 = claim_element(div4_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Unwrap ");
			span = claim_element(h1_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t1 = claim_text(span_nodes, "sBTC");
			span_nodes.forEach(detach_dev);
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(div4_nodes);
			h2 = claim_element(div4_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t3 = claim_text(h2_nodes, "sBTC to BTC");
			h2_nodes.forEach(detach_dev);
			t4 = claim_space(div4_nodes);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(sbtcwalletdisplay.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", {});
			var div1_nodes = children(div1);
			if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "strokeme-warning");
			add_location(span, file, 33, 35, 1446);
			attr_dev(h1, "class", "text-warning s-sCjUEJHBVR8B");
			add_location(h1, file, 33, 3, 1414);
			attr_dev(h2, "class", "text-warning mb-3");
			add_location(h2, file, 34, 3, 1497);
			attr_dev(div0, "class", "my-3 d-flex justify-content-between text-white");
			add_location(div0, file, 35, 3, 1547);
			add_location(div1, file, 40, 5, 1730);
			attr_dev(div2, "class", "card border p-4");
			add_location(div2, file, 39, 4, 1695);
			attr_dev(div3, "class", "d-flex justify-content-center");
			add_location(div3, file, 38, 3, 1647);
			attr_dev(div4, "class", "card-width");
			add_location(div4, file, 32, 2, 1386);
			attr_dev(div5, "class", "my-4 p-4");
			add_location(div5, file, 31, 1, 1361);
			attr_dev(section, "class", "bg-dark s-sCjUEJHBVR8B");
			add_location(section, file, 30, 0, 1334);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);
			append_hydration_dev(section, div5);
			append_hydration_dev(div5, div4);
			append_hydration_dev(div4, h1);
			append_hydration_dev(h1, t0);
			append_hydration_dev(h1, span);
			append_hydration_dev(span, t1);
			append_hydration_dev(div4, t2);
			append_hydration_dev(div4, h2);
			append_hydration_dev(h2, t3);
			append_hydration_dev(div4, t4);
			append_hydration_dev(div4, div0);
			mount_component(sbtcwalletdisplay, div0, null);
			append_hydration_dev(div4, t5);
			append_hydration_dev(div4, div3);
			append_hydration_dev(div3, div2);
			append_hydration_dev(div2, div1);
			if_blocks[current_block_type_index].m(div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div1, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sbtcwalletdisplay.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(sbtcwalletdisplay.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(sbtcwalletdisplay);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let view;
	let $sbtcConfig;
	validate_store(sbtcConfig, 'sbtcConfig');
	component_subscribe($$self, sbtcConfig, $$value => $$invalidate(5, $sbtcConfig = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Page', slots, []);

	let poTx = $sbtcConfig.pegOutTransaction && $sbtcConfig.pegOutTransaction.ready
	? PegOutTransaction.hydrate($sbtcConfig.pegOutTransaction)
	: new PegOutTransaction();

	let sigData;

	const openSigView = () => {
		$$invalidate(0, poTx = PegOutTransaction.hydrate($sbtcConfig.pegOutTransaction));
		if (!poTx.pegInData.stacksAddress) poTx.setStacksAddress(addresses().stxAddress);
		const signature = $sbtcConfig.sigData.signature;
		const txs = poTx.buildTransaction(signature);

		$$invalidate(1, sigData = {
			pegin: false,
			webWallet: poTx.fromBtcAddress === addresses().cardinal,
			txs,
			outputsForDisplay: poTx.getOutputsForDisplay(),
			inputsForDisplay: poTx.addressInfo.utxos
		});

		$$invalidate(2, view = 'sign_tx_view');
	};

	const updateTransaction = () => {
		$$invalidate(2, view = 'build_tx_view');
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Page> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		BuildTransaction,
		SignTransaction,
		SignTransactionWeb,
		SbtcWalletDisplay,
		sbtcConfig,
		PegOutTransaction,
		addresses,
		poTx,
		sigData,
		openSigView,
		updateTransaction,
		view,
		$sbtcConfig
	});

	$$self.$inject_state = $$props => {
		if ('poTx' in $$props) $$invalidate(0, poTx = $$props.poTx);
		if ('sigData' in $$props) $$invalidate(1, sigData = $$props.sigData);
		if ('view' in $$props) $$invalidate(2, view = $$props.view);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$invalidate(2, view = 'build_tx_view');
	return [poTx, sigData, view, openSigView, updateTransaction];
}

class Page extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init$1(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Page",
			options,
			id: create_fragment.name
		});
	}
}

export { Page as default };
